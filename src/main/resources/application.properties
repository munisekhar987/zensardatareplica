# CDC Consumer Application Configuration

# Server Configuration
server.port=9095
spring.application.name=CDC-DataReplicationAPP

# Kafka Configuration
spring.kafka.bootstrap-servers=localhost:9092
spring.kafka.consumer.group-id=multi-cdc-consumer
spring.kafka.consumer.auto-offset-reset=earliest
spring.kafka.consumer.key-deserializer=org.apache.kafka.common.serialization.StringDeserializer
spring.kafka.consumer.value-deserializer=org.apache.kafka.common.serialization.StringDeserializer

# CDC Topic Configuration
# Comma-separated list of Kafka topics to consume from
cdc.kafka.topics=mypg.public.handoff_batchroute,mypg.public.deliveryconfirm,mypg.public.handoff_batchstop

# Topic to Table Mappings Configuration
# Format: Topic name -> Table name
cdc.topic.table-mappings={'mypg.public.handoff_batchroute': 'HANDOFF_BATCHROUTE',\
  'mypg.public.handoff_batchstop' : 'HANDOFF_BATCHSTOP' ,\
  'mypg.public.deliveryconfirm' : 'DELIVERYCONFIRM'}

# Primary Key Configuration for Tables
# Format: Table name -> comma-separated list of primary key column names
cdc.table.primary-keys={'HANDOFF_BATCHROUTE': 'BATCH_ID' , 'HANDOFF_BATCHSTOP' : 'BATCH_ID,WEBORDER_ID' }

# Tables that allow duplicates (no primary key or unique constraint)
# For tables where duplicates are allowed or no primary key constraint exists
cdc.tables.allow-duplicates=DELIVERYCONFIRM



# Duplicate Handling Strategy
# Options: merge, upsert, ignore, none
# merge - Uses Oracle's MERGE statement to handle duplicates (recommended)
# upsert - Try update first, if not exists then insert
# ignore - Check if record exists first, only insert if not found
# none - Standard insert (will fail on duplicates)
cdc.handle.duplicates=merge

# Oracle Database Connection Configuration
oracle.db.url=jdbc:oracle:thin:@localhost:1521/XEPDB1
oracle.db.username=system
oracle.db.password=admin
oracle.db.schema=SYSTEM

# PostgreSQL Source Configuration (for UDT support)
postgres.db.url=jdbc:postgresql://localhost:5432/postgres
postgres.db.username=postgres
postgres.db.password=mysecretpassword
postgres.db.schema=public

# Tables with UDT columns that need supplementary fetching
# Format: table_name:primary_key_column
postgres.udt.tables=HANDOFF_BATCHROUTE:BATCH_ID

# UDT Type Mapping Configuration - FIXED FORMAT FOR SPRING SPEL
# The format must use proper SpEL expression with map notation
postgres.udt.type-mapping={'handoff_routing_route_no':'HANDOFF_ROUTING_ROUTE_NO', 'handoff_roadnet_route_no':'HANDOFF_ROADNET_ROUTE_NO'}

# UDT Column Mapping Configuration - FIXED FORMAT FOR SPRING SPEL
# The format must use proper SpEL expression with map notation
postgres.udt.column-mapping={'HANDOFF_BATCHROUTE.ROUTING_ROUTE_NO':'handoff_routing_route_no', 'HANDOFF_BATCHROUTE.ROADNET_ROUTE_NO':'handoff_roadnet_route_no'}

# Logging Configuration
logging.level.com.zensar.data.replication=INFO
logging.level.com.zensar.data.replication.consumer=DEBUG
logging.level.com.zensar.data.replication.service=DEBUG
logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss.SSS} %highlight(%-5level) %cyan(%-40logger{40}) : %msg%n